<?php

class OCVMScan {


	private $settings;
	private $scan_data  = null;
	private $last_scan_data = array();
	private $items_without_fixed_in  = array();
	private $versions   = array(
		'wp'      => ONECOM_WP_CORE_VERSION,
		"plugins" => [],
		"themes"  => []
	);
	private $http_error = false;
	private $http_response;
	private $http_args = array(
		'timeout'     => 10,
		'httpversion' => '1.0',
		'compress'    => false,
		'decompress'  => true,
		'sslverify'   => true,
		'stream'      => false,
	);

	public $isNewVulnerabilityExist = false;
	public $isFixVersionMissing     = false;
	public function __construct() {
		$this->settings = new OCVMSettings();
		$this->setCron();
	}

	public function collectVersions(): void {

		// get all active plugins
		$activePlugins = get_site_option('active_plugins');

		// active plugins' slug and version
		foreach ( $activePlugins as $activePlugin ) {
			$this->versions['plugins'][] = array(
				"slug"              => explode(DIRECTORY_SEPARATOR, $activePlugin)[0],
				"installed_version" => get_plugin_data(WP_PLUGIN_DIR . DIRECTORY_SEPARATOR . $activePlugin, false, false)['Version']
			);
		}

		// in case current theme is a child theme then fetch parent theme's details
		if ( get_template_directory() !== get_stylesheet_directory() && ! empty(wp_get_theme()->parent()) ) {
			$theme = wp_get_theme()->parent();
		} else {

			// get active theme
			$theme = wp_get_theme();
		}
		// active theme's slug and version
		$this->versions['themes'][] = array(
			"slug"              => $theme->template,
			"installed_version" => $theme->version
		);
	}

	/**
	 * Send versions of all plugins/themes/core
	 */
	public function sendVersions() {
		// stats
		$this->sendVersionStats($this->versions);

		// http call
		$this->http_args['user-agent'] = 'WordPress/' . ONECOM_WP_CORE_VERSION . '; ' . home_url();
		$this->http_args['body']       = json_encode($this->versions);
		$this->http_response           = wp_remote_post($this->settings::ocvm_endpoint, $this->http_args);
	}

	/**
	 * Process http_response
	 */
	public function processResponse() {
		if ( is_wp_error($this->http_response) ) {
			if ( isset($this->http_response->errors['http_request_failed']) ) {
				$this->http_error = __('Connection timed out', OC_VALIDATOR_DOMAIN);
			} else {
				$this->http_error = $this->http_response->get_error_message();
			}
		} else {
			if ( wp_remote_retrieve_response_code($this->http_response) != 200 ) {
				$this->http_error = '(' . wp_remote_retrieve_response_code($this->http_response) . ') ' . wp_remote_retrieve_response_message($this->http_response);
			} else {
				$body    = wp_remote_retrieve_body($this->http_response);
				$bodyArr = json_decode($body, 1);
				if ( null !== $bodyArr['error'] ) {
					error_log("Error reported by API endpoint --> " . $body);
				} else {
					// To handle the case of plugins that are having same slug for free and pro version but different names
					$plugins_array = $bodyArr['data']['plugins'] ?? array();
					if ( is_array( $plugins_array ) ) {
						foreach ( $plugins_array as $plugin => $vulnerabilities ) {
							$name = $this->get_name_for_slug( $plugin, 'plugins' );
							foreach ( $vulnerabilities['vulnerabilities'] as $key => $value ) {
								if ( isset( $value['product_name_premium'] ) && '' !== $value['product_name_premium'] && $name !== $value['product_name_premium'] ) {
									error_log( 'vulnerability for the premium version of plugin found removing it..' );
									unset( $plugins_array[ $plugin ]['vulnerabilities'][ $key ] );
									// Check if vulnerabilities array is empty after unset
									if ( empty( $plugins_array[ $plugin ]['vulnerabilities'] ) ) {
										unset( $plugins_array[ $plugin ] );
										break;
									}
								}
							}
						}
					}
					$this->scan_data = array_merge(
						array(
							'plugins' => (array) $plugins_array,
							'themes'  => (array) $bodyArr['data']['themes'],
							'wp'      => (array) $bodyArr['data']['wp']
						)
					);
				}
			}
		}
	}

	/**
	 * Check if Vulnerability reported by Endpoint
	 * If no vulnerabilities, clear existing vulnerabilities in db
	 */
	public function vulnerabilityExists(): bool {
		if (
			empty($this->scan_data['wp']) &&
			empty($this->scan_data['plugins']) &&
			empty($this->scan_data['themes'])
		) {
			// Get existing VM data
			$existing_vm_data = $this->settings->get();

			// if no vulnerability exits now, push existing vulnerability (if any) to VM log as they are fixed (via update, delete, deactivation)
			$fixed_vuls = $existing_vm_data['vulnerabilities'];
			if ( count($fixed_vuls) > 0 ) {
				$history_log_obj = new OCVMHistoryLog();
				$history_log_obj->iterateVulnerabilitiesForLog($fixed_vuls);
			}

			// As no vulnerability found in this scan, clear existing vulnerabilities (however retain settings)
			$existing_vm_data['vulnerabilities'] = array();
			$this->settings->update($existing_vm_data);

			return false;
		}
		return true;
	}

	/**
	 * Get FQN of plugin by slug
	 * @param $slug string Theme's stylesheet or Plugin's PHP dir name
	 * @return string Name of the plugin/theme
	 */
	protected function get_name_for_slug($slug, $type): string {
		if ( "themes" === $type ) {
			// theme headers
			$themeData = wp_get_theme($slug);
			return $themeData->get('Name');
		}

		require_once ABSPATH . 'wp-admin/includes/plugin.php';
		$plugin_files = get_plugins('/' . $slug);
		if ( ! $plugin_files ) {
			return '';
		}
		$plugin_files = array_keys($plugin_files);
		$plugin_dir   = $slug . '/' . reset($plugin_files);
		$pluginData   = get_plugin_data(trailingslashit(WP_PLUGIN_DIR) . $plugin_dir);
		return $pluginData['Name'];
	}

	/**
	 * Iterator
	 */
	public function arrayIterator($items, $type = 'plugins') {

		$arrItems = [];
		foreach ( $items as $slug => $vuls ) {
			// find the highest fix version across all the vulnerabilities found for this item
			$arrItems[$slug]["fixed_in"] = max(array_column($vuls['vulnerabilities'], 'fixed_in'));
			$arrItems[$slug]["name"]     = $this->get_name_for_slug($slug, $type);
			$arrItems[$slug]             = array_merge($arrItems[$slug], $vuls);

			// cleanup duplicate vulnerability codes
			$vulsArr = [];
			foreach ( $arrItems[$slug]['vulnerabilities'] as $k => $v ) {

				//check is fixed version is missing
				if ( $arrItems[$slug]["vulnerabilities"][$k]["fixed_in"] === "" ) {
					// Store items with missing fixed-in, to prevent repeat mail after update attempt
					if (!array_key_exists($type,$this->items_without_fixed_in) || !in_array($slug, $this->items_without_fixed_in[$type])) {
						$this->items_without_fixed_in[$type][] = $slug;
					}
					error_log("Fixed in missing for ".$type);
					$this->isFixVersionMissing = true;
				}
				//round cvss score at two decimal points
				$arrItems[$slug]["vulnerabilities"][$k]["cvss_score"] = sprintf('%.2f', $arrItems[$slug]["vulnerabilities"][$k]["cvss_score"]);
				$v["cvss_score"] = sprintf('%.2f', $v["cvss_score"]);

				$vulnType = $v['vuln_type'];
				$fixedIn  = $v['fixed_in'];

				if ( isset($vulsArr[$vulnType]) ) {
					// Compare fixed_in values to keep the one with the higher fixed_in value
					$existingFixedIn = $vulsArr[$vulnType]['fixed_in'];
					if ( version_compare($fixedIn, $existingFixedIn, '>') ) {
						// Replace the existing vulnerability with the new one
						$vulsArr[$vulnType] = $v;
					} elseif ( version_compare($fixedIn, $existingFixedIn, '<=') ) {
						unset($arrItems[$slug]['vulnerabilities'][$k]);

					}
				}else {
					$vulsArr[$vulnType] = $v;

				}
			}
			// Convert the associative array back to a sequential array
			$arrItems[$slug]['vulnerabilities'] = array_values($vulsArr);
		}
		return $arrItems;
	}

	/**
	 * Save vulnerabilities in DB
	 */
	public function saveVulnerabilities() {
		$existing        = $this->settings->get();
		$dbData          = array();
		$history_log_obj = new OCVMHistoryLog();
		//TODO: delete the entries of plugins/themes/core from $existing data if any of them dont exist now.
		// This is required to clean up stale data and to avoid sending/showing irrelevant mails/notifications.
		if ( ! empty($this->scan_data['plugins']) ) {
			$dbData['plugins'] = $this->arrayIterator($this->scan_data['plugins']);
		}

		if ( ! empty($this->scan_data['themes']) ) {
			$dbData['themes'] = $this->arrayIterator($this->scan_data['themes'], 'themes');
		}

		if ( ! empty($this->scan_data['wp']) && ! empty($this->scan_data['wp']['vulnerabilities']) ) {

			$temp       = array_unique(array_column($this->scan_data['wp']['vulnerabilities'], 'vuln_type'));
			$unique_vul = array_intersect_key($this->scan_data['wp']['vulnerabilities'], $temp);
			shuffle($unique_vul);

			foreach ( $unique_vul as $k => $v ) {

				//check is fixed version is missing
				if ( $v["fixed_in"] === "" ) {
					error_log("Fixed in missing for WP");
					$this->items_without_fixed_in['wp'] = '';
					$this->isFixVersionMissing = true;
				}
				//round cvss score at two decimal points
				$unique_vul[$k]["cvss_score"] = sprintf('%.2f', $unique_vul[$k]["cvss_score"]);
			}

			$wp_vuls = $unique_vul;

			$dbData['wp']['installed_version'] = $this->scan_data['wp']['installed_version'];
			$dbData['wp']['fixed_in']          = max(array_column($wp_vuls, 'fixed_in'));
			$dbData['wp']['vulnerabilities']   = $wp_vuls;
			$dbData['wp']['name']              = "WordPress Core";
		}

		//check is new vulnerability exist
		$this->isNewVulnerabilityFound($dbData, $existing);

		if ( empty($existing['vulnerabilities']) ) {
			$existing['vulnerabilities'] = $dbData;
		} else {
			$this->last_scan_data = $this->extractVulnerableItems($existing['vulnerabilities']);

			// if existing vulnerabilities are not in latest scan (updated, deleted, or deactivated), push to VM log
			$fixed_vuls = $history_log_obj->extractFixedVulnerabilities($existing['vulnerabilities'], $dbData);

			if ( count($fixed_vuls) > 0 ) {
				error_log("Fixed vulnerabilities found to push in log");
				$history_log_obj->iterateVulnerabilitiesForLog($fixed_vuls);
			} else {
				error_log("No fixed vulnerabilities found so far");
			}

			$existing['vulnerabilities'] = $dbData;
		}

		// save all vulnerabilities
		$existing['vulnerabilities'] = $dbData;

		$this->settings->update($existing);
	}

	/**
	 * Check is found any new vulnerability
	 * @param $newVul
	 * @param $existingVul
	 * @return void
	 */
	public function isNewVulnerabilityFound($newVul, $existingVul) {
		global $wp_version;

		if ( ! is_array($newVul) && ! is_array($existingVul) ) {
			return;
		}

		error_log('~~~ Checking for new vulnerability ~~~');

		//Prepare default structure for vulnerability check
		$newVul                         = $newVul + array("plugins" => [], "themes" => [], "wp" => ["vulnerabilities" => []]);
		$existingVul['vulnerabilities'] = $existingVul['vulnerabilities'] + array("plugins" => [], "themes" => [], "wp" => ["vulnerabilities" => []]);

		$pluginCheck = (isset($newVul["plugins"])) ? array_diff_key($newVul["plugins"], $existingVul['vulnerabilities']["plugins"]) : array();

		//check new vulnerability for themes
		$themeCheck = (isset($newVul["themes"])) ? array_diff_key($newVul["themes"], $existingVul['vulnerabilities']["themes"]) : array();

		//check new vulnerability for WP
		$existingWP = isset($existingVul['vulnerabilities']["wp"]["vulnerabilities"]) ? count($existingVul['vulnerabilities']["wp"]["vulnerabilities"]) : 0;

		$newWP = (isset($newVul["wp"]["vulnerabilities"])) ? count($newVul["wp"]["vulnerabilities"]) : 0;

		//get new vulnerability regarding WP core
		$wpCheck = $newWP - $existingWP;

		//get the max fixed_in version
		$ver          = ($newWP > 0) ? max(array_column($newVul["wp"]["vulnerabilities"], 'fixed_in')) : $wp_version;
		$userSettings = $this->settings->get();

		//check is installed WP and coming WP vulnerability fixed_in are same or empty
		//then, override the WP vulnerability if found the same version during auto-update on
		if ( version_compare($wp_version, $ver) >= 0 && 1 == $userSettings['settings']['auto_update'] ) {
			$wpCheck = 0;
		}

		if ( count($pluginCheck) > 0 || count($themeCheck) > 0 || $wpCheck > 0 ) {
			error_log('~~~ New vulnerability found ~~~');
			$this->isNewVulnerabilityExist = true;
			return;
		}
		error_log('~~~ No new vulnerability found ~~~');
	}

	/**
	 * Check and Display Vulnerabilities if any
	 */
	public function manageVulnerabilities(): void {
		error_log("Scan started!");

		self::collectVersions();

		self::sendVersions();

		self::processResponse();

		if ( false !== $this->http_error ) {
			error_log("Error found -- " . $this->http_error);
			return;
			// stop execution and log error if required
		}

		if ( null === $this->scan_data ) {
			error_log("No data found from API response -- " . json_encode($this->http_response));
			return;
			// stop execution and log error if required
		}

		if ( true !== self::vulnerabilityExists() ) {
			error_log("No vulnerabilities found! All good! Exiting...");
			return;
		}

		error_log("Vulnerabilities found!");
		self::saveVulnerabilities();

		// get user's preferences
		$userSettings = $this->settings->get();
		$notifyAdmins = new OCVMSendEmails();

		//get daily email send status
		$dailyEmailSent = get_site_transient('ocvm_daily_email_sent');

		//Allow auto-update only for mWP
		if ( 1 == $userSettings['settings']['auto_update'] && $this->settings->isPremium()) {

			// Auto-update items
			$autoUpdate = new OCVMAutoUpdates();
			$autoUpdate->updateItems();

			// check user's preferences for email type, send vuls-fixed and vuls-found email
			if (
				1 === $userSettings['settings']['notify_all'] &&
				1 === $userSettings['settings']['email_type']['email_fixed'] &&
				current_action() === 'ocvm_scan'
			) {
				error_log("Sending vuls-fixed / vuls-found on ocvm_scan run as per requirement");
				$this->fixedAndNoAutoFixedEmail($notifyAdmins, $autoUpdate);
			}

		} else {

			// check user's preferences for email type
			if (
				1 === $userSettings['settings']['notify_all'] &&
				1 === $userSettings['settings']['email_type']['email_detect']
			) {

				// send vuls-found email
				// on new vulnerability found we will send always email
				// ocvm_scan should run once a day if email is not sent for a day
				// if email is already sent, then will skip sending email via ocvm_scan
				// otherwise, we will skip sending email
				if ( $this->isNewVulnerabilityExist ) {
					error_log("Sending email on new vulnerability found.");
					$notifyAdmins->sendEmail();
					( ! $dailyEmailSent) ? set_site_transient('ocvm_daily_email_sent', 'yes', 7 * DAY_IN_SECONDS) : '';
				} else if ( current_action() === 'ocvm_scan' && ! $dailyEmailSent ) {
					error_log("Sending email on ocvm_scan run");
					$notifyAdmins->sendEmail();
					//set site transient for 24hr
					set_site_transient('ocvm_daily_email_sent', 'yes', 7 * DAY_IN_SECONDS);
				} else {
					error_log("Skip sending email because no new vulnerability found.");
				}
			}
		}
	}

	public function fixedAndNoAutoFixedEmail($notifyAdmins, $autoUpdate) : void {
		error_log("Sending email for vulnerability on the basis of condition");
		//send auto-update email for vulnerability fixed if no case of missing fixed version
		if ( ! $this->isFixVersionMissing ) {
			error_log("Sending email only for fixed vulnerability");
			$notifyAdmins->sendEmail("vulsFixed", $autoUpdate->updateAttempt);
			return;
		}

		// Send vulsNotAutoFixed only if any fixed version is missing and weekly mail is not sent or new vul found
		$dailyEmailSent = get_site_transient('ocvm_daily_email_sent');
		if ( current_action() === 'ocvm_scan'
			&& (! $dailyEmailSent || !$this->vulExistsInLastScan($this->items_without_fixed_in, $this->last_scan_data))
		) {
			$notifyAdmins->sendEmail("vulsNotAutoFixed", $autoUpdate->updateAttempt);
			set_site_transient('ocvm_daily_email_sent', 'yes', 7 * DAY_IN_SECONDS);
		}

		error_log("Sending email for vulnerability fix always");
		$notifyAdmins->sendEmail("vulsFixed", $autoUpdate->updateAttempt);
	}

	/**
	 * Set cron if not exists
	 */
	public function setCron() {
		if ( ! wp_next_scheduled($this->settings::wpcron_hook) ) {
			wp_schedule_event(
				time(),
				'daily',
				// TODO: enable 24 hours duration before real deployment
				// $this->settings->get()['scan_duration'],
				$this->settings::wpcron_hook
			);
		}
	}

	/**
	 * Prepare vulerable (last scan) items names, rmove `vulnerablities` and extra data
	 *
	 * @return array
	 */
	public function extractVulnerableItems($vuls) : array {
		$vul_items = array();
		foreach ($vuls as $item => $value) {
			// Get vulnerable plugins and themes slugs
			if ($item === 'plugins' || $item === 'themes') {
				$vul_items[$item] = array_keys($value);
			} else if ($item === 'wp') {
				$vul_items[$item] = '';
			}
		}

		return $vul_items;
	}

	/**
	 * Check if all current i.e new vulnerable (missing fixed-in) items were already exists in last scan
	 * If exists (and weekly mail sent), we will prevent sending 'vulsNotAutoFixed' mail after auto update
	 *
	 * @return bool
	 */
	public function vulExistsInLastScan($new_vuls, $old_vuls) : bool {
		foreach ($new_vuls as $type => $items) {
			// Return false if the 'plugins', 'themes' or 'wp' key found in new_vuls does not exists in old_vuls
			if (!isset($old_vuls[$type])) {
				return false;
			}

			// Return false any plugin/theme from new_vuls does not exists in old_vuls, else return true as all vuls found in last scan
			foreach ($items as $item) {
				if (!in_array($item, $old_vuls[$type])) {
					return false;
				}
			}
		}
		return true;
	}

	/**
	 * Delete cron upon deactivation
	 */
	public function deleteCron() {
		$timestamp = wp_next_scheduled('bl_cron_hook');
		wp_unschedule_event($timestamp, 'bl_cron_hook');
	}

	/**
	 * Schedule WPCron scan scheduling after 30sec for multiple events (activation, deactivation, updation, deletion)
	 * @param $plugin
	 * @param $network_wide
	 * @return void
	 */
	public function scheduleOCVMScan() {
		wp_schedule_single_event(time() + 30, 'ocvm_scan');
	}

	/**
	 * Schedule event after 30sec of auto update enabled
	 *
	 * @return void
	 */
	public function scheduleCronAfterAutoupdate() {
		wp_schedule_single_event(time() + 30, 'ocvm_scan');
	}

	/**
	 * Send version stats
	 */
	public function sendVersionStats($ver = []): void {
		if ( empty($ver) ) {
			return;
		}
		class_exists('OCPushStats') ?
			OCPushStats::push_vul_monitor_stats('scan', 'setting', 'vulnerability_monitor', ['active_versions' => $ver]) :
			'';
	}

}